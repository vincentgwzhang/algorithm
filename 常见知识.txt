______________________________________________________________
|           │ Class │ Package │ Subclass │ Subclass │ World  |
|           │       │         │(same pkg)│(diff pkg)│        |
|───────────┼───────┼─────────┼──────────┼──────────┼────────|
|public     │   +   │    +    │    +     │     +    │   +    |
|───────────┼───────┼─────────┼──────────┼──────────┼────────|
|protected  │   +   │    +    │    +     │     +    │        |
|───────────┼───────┼─────────┼──────────┼──────────┼────────|
|no modifier│   +   │    +    │    +     │          │        |
|───────────┼───────┼─────────┼──────────┼──────────┼────────|
|private    │   +   │         │          │          │        |
|___________|_______|_________|__________|__________|________|

说明： protected 和 no modifier 的区别在于，在不同的 package 下， 子类能够使用父类标有 protected 的函数，而不能使用父类无访问修饰符的函数
或者这么说：
A subclass, which in different package, can use its parent class which marked "protected" function. But it can not use its parent class which has "no modifier" function

===========================================================================

线性结构常见： 
数组，队列，链表，栈

顺序存储(存储元素    一定连续)：数组
链式存储(存储元素不一定连续)：链表


非线性结构：
二维数组，多维数组，广义表，树结构，图结构

===========================================================================

稀疏数组: 如果二维数组很多值默认是0等无意义值的话，就可以使用稀疏数组保存该数组


---------------------------------------------------------------------------

时间复杂度

第一种情况
假如无论数字多大，运算时间都不随数字而改变，则 O(1)

第二种情况 log2N
int i = 1;
while ( i < n ) {
    i = i * 2;
}

T(n) <= O(f(n))
2 ^ i < n
lg(2^i) < lg(n)
i * lg2 <= lg n
i <= lg n / lg 2
i <= log2N (2是对数)

第三中情况
for(int i = 0; i < n; i++) ----> O(n)

第四中情况

for(int i = 0; i < n; i ++) {
 for(int j = 1 ; j < n; j++) {
    j = j * 2
 }}

 n * log2 N

 第五中情况
 平方阶 O(n ^ 2) 就是2重循环

===========================================================================
冒泡， 交换，选择，插入，             O(n^2)
基数排序                           O(logR B)
shell, 快速，归并, 堆排序            O(nlogN)

===========================================================================

===========================================================================
maven scope:
1. Compile. 默认就是compile，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。
2. Test.    scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。
3. Runtime. 表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译，只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为 Runtime
4. Provided.意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。
5. System.  从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。
6. Import依赖关系实际上并不参与限制依赖关系的传递性。

_________________________________
|           │ Compile │ Package │
|           │         │         │
|───────────┼─────────┼─────────┼
|Compile    │   +     │    +    │
|───────────┼─────────┼─────────┼
|Test       │   +     │    +    │
|───────────┼─────────┼─────────┼
|Runtime    │         │    +    │
|───────────┼─────────┼─────────┼
|Provided   │   +     │         │
|___________|_________|_________|



===========================================================================
Spring中用到的九种设计模式

工厂模式, BeanFactory
单例模式（Singleton）Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定
观察者（Observer）如ApplicationListener。
Spring AOP 就是基于动态代理的
适配器模式
