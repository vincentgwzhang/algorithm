eureka AP
Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。
而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，
只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)，其中说明了，eureka是不满足强一致性，但还是会保证最终一致性


zookeeper CP
zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务，这个时候就说明了服务不可用，但是在选举成功之后，
因为一主多从的结构，zookeeper在这时还是一个高可用注册中心，只是在优先保证一致性的前提下，zookeeper才会顾及到可用性


Benifit for Microservice:
1, 分解巨大单体式应用为多个服务方法解决了复杂性问题
2, 这种架构使得每个服务都可以有专门开发团队来开发
3, 微服务架构模式是每个微服务独立的部署。
4, 微服务架构模式使得每个服务独立扩展

CONS for Microservice:
1, Generally speaking, the application is not big function
2, Deal with consistence because use different database
3, 微服务架构带来的复杂性。




微服务如何通信
1, 无代理模式

POS:
- 低延迟
- 易于实施
- 易于调试
- High throughput

COS:
- 服务发现
- 紧耦合

2, 消息传递总线（代理）设计
在这种体系结构中，所有通信都通过一组代理进行路由。代理是运行某些高级路由算法的服务器程序。
POS:
- 负载均衡
- Service discover

COS:
- Maintain
- High lagacy
- Proxy need CPU / Memory ...




============================================================================================

微服务架构的十个设计模式分别是


/////////////////////////////////////////////////////////////////////
01, 独享数据库

优点
数据由服务完全所有
服务的开发团队之间耦合度降低

缺点
服务间的数据共享变得更有挑战性
在应用范围的保证 ACID 事务变得困难许多
细心设计如何拆分单体数据库是一项极具挑战的任务
/////////////////////////////////////////////////////////////////////
02, 事件驱动

Event Sourcing采用类似数据库的事务日志的方式，将所有对象的状态变更记录在事件库中，并通过API支持应用订阅和查询事件。因此通过事件库中的事件序列，可以获知系统中对象状态的变更。
- 帐户服务和交易服务分别向事件库订阅交易事件和帐户事件
- 交易服务发起交易，会在事件库中生成“发起交易”事件
- 帐户服务收到此事件后，在金额条件满足的情况下，生成“帐户金额变更”事件
- 交易服务收到此事件后，确定交易成功，发布交易成功事件

//////////////////////////////////////////////////////////////////////

03, CQRS

命令操作仍然通过各服务的 API 以   $$$$更新事件列表$$$$$   的方式进行，而查询操作则通过一个统一的视图查询服务（View Query Service）完成。

04, Saga
05, BFF
06, API 网关
07, Strangler
08, 断路器
09, 外部化配置
10, 消费端驱动的契约测试。

=============================================================================================