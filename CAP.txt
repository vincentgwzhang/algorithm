一致性（Consistency）
可用性（Availability）
分区容错性（Partition tolerance）



3. BASE理论
3.1 基本可用（Basically Available）
3.2 软状态（ Soft State）
最终一致性（ Eventual Consistency）




ACID:
-  原子性（Atomicity）
-  一致性（Consistency）
-  隔离性（Isolation）
-  持久性（Durability）
Saga:
-  一致性（Consistency）
-  持久性（Durability）


Actually, ACID vs BASE, is single application vs microserve, for event consistency!



================================================================================================

数据一致性解决方案 1:

Saga == Long live transaction

Saga是一个长活事务，可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。

当每个saga子事务 T1, T2, …, Tn 都有对应的补偿定义 C1, C2, …, Cn-1, 那么saga系统可以保证 [1]

子事务序列 T1, T2, …, Tn得以完成 (最佳情况)
或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 < j < n, 得以完成







================================================================================================

数据一致性解决方案 2:
两阶段提交 Two-Phase Commit (2PC)  [两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。]

vote request -> yes / no
commit / abort -> DONE

　　1）两阶段提交涉及多次节点间的网络通信，通信时间太长！
　　2）事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多！


投票阶段: 协调器向所有服务发起投票请求，服务回答yes或no。如果有任何服务回复no以拒绝或超时，协调器则在下一阶段发送中止消息。 
决定阶段: 如果所有服务都回复yes，协调器则向服务发送commit消息，接着服务告知事务完成或失败。如果任何服务提交失败， 协调器将启动额外的步骤以中止该事务。 





================================================================================================

数据一致性解决方案 3:
Try-Confirm/Cancel (TCC)
尝试阶段 将服务置于待处理状态。例如，收到尝试请求时，航班预订服务将为客户预留一个座位，并在数据库插入客户预订记录，将记录设为预留状态。 如果任何服务失败或超时，协调器将在下一阶段发送取消请求。 
确认阶段 将服务设为确认状态。确认请求将确认客户预订的座位，这时服务已可向客户收取机票费用。数据库中的客户预订记录也会被更新为确认状态。 如果任何服务无法确认或超时，协调器将重试确认请求直到成功，或在重试了一定次数后采取回退措施，比如人工干预。 

try -> reserved
confirm / cancer -> done


TCC的缺点是其两阶段协议需要设计额外的服务待处理状态，以及额外的接口来处理尝试请求


================================================================================================

数据一致性解决方案 4:
Event-Driven
一旦长活事务中的最后一个服务完成其子事务，它将通知它在事务中的前一个服务。接收到完成事件的服务将其在数据库中的记录状态设为完成。